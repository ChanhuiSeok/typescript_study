## 타입의 모든 것

- 타입(type) : 값과 이 값으로 할 수 있는 일의 집합

예를 들어 아래와 같은 함수가 있다고 가정해 본다.

```js
function squareOf(n){
  return n*n;
}
squareOf(2); // 4
squareOf('Z'); // NaN(Not a Number)
```
squareOf 함수는 파라미터로 숫자를 받음이 명확하기 때문에 매개변수에 타입을 명시한다.

```js
function squareOf(n: number){
  return n*n;
}
squareOf(2); // 4
squareOf('Z'); // TS2345 에러 발생
```

숫자가 아닌 타입을 넘길 때, 타입스크립트는 바로 에러를 발생시킬 수 있다.

타입스크립트는 특정 타입만 와야 할 때, 이를 명시할 수 있는 언어라는 사실을 이해해야 한다.

---

## 여러 가지 타입

### any
- 프로그래머와 타입스크립트 둘 다 타입을 알 수 없는 상황일 때는 기본 타입인 any로 가정하게 된다.
- any는 뭐든지 할 수 있는 타입이지만 꼭 필요한 상황이 아니면 사용하지 않는 것이 좋다.(최후의 보루 느낌)

any는 모든 값의 집합이라, any라는 타입의 값이 있으면 덧셈, 곱셈, 호출 등 무슨 작업이든 다 가능하다.
그러므로 타입스크립트가 자바스크립트처럼 동작하게 되면서 타입 검사기라는 기능이 더 이상 작동하지 않는다.

그러므로 되도록 피하라고 하는 것이다.

### unknown
- 타입을 미리 알 수 없는 어떤 값이 있다면, any 대신 unknown을 사용하도록 하자.
- any처럼 unknown도 모든 값을 대표하긴 하지만, unknown의 타ㅣ블 검사해 정제(refine)하기 전까지는 타입스크립트가 unknown 타입의 값을 사용할 수 없게 강제한다.

```ts
let a: unknown = 30; // unknown
let b = a === 123; // boolean
let c = a + 10; // TS2571 에러 - 객체의 타입이 unknown임
if (typeof a === 'number'){ // unknown의 타입을 검사해 정제(refine)
  let d = a + 10;
}
```

### boolean
boolean 타입은 true, false 두 가지 갑슬 가진다. 이 타입으로는 비교 연산을 할 수 있다.

어떤 값이 boolean인지 지정하는, 타입스크립트에 알려줄 수 있는 여러 방법이 있다.

1. 어떤 값이 boolean인지 타입스크립트가 추론하게 한다.
```ts
let a = true; // a는 boolean
```
2. 어떤 값이 특정 boolean인지 타입스크립트가 추론하게 한다.
```ts
const c = true; // c는 true
```
여기서 const로 선언한 c는 앞으로 절대 변할 일이 없다는 사실을 알게 되어서, 해당 변수가 가질 수 있는 가장 좁은 타입인 true로 추론하게 된 것이다. 이 기능을 `타입 리터럴`이라고 한다. `타입 리터럴`이란 오직 하나의 값을 나타내는 타입을 의미한다.

3. 값이 boolean임을 명시적으로 타입스크립트에게 알리거나, 특정 boolean임을 명시적으로 알린다.
```ts
let d: boolean = true; // boolean (거의 사용할 일은 없음)
let e: true = true; // true
```

`타입 리터럴` 기능은 모든 곳에서 일어날 수 있는 실수를 방지해 안전성을 추가로 확보해주는 강력한 언어 기능이다.

### number
number 타입은 모든 숫자(정수, 소수, 양수, 음수, Infinity, NaN 등)의 집합이며 숫자 관련 연산을 수행할 수 있다.

> 꿀팁 : 긴 숫자를 처리할 때, 숫자 분리자를 이용해 숫자를 읽기 쉽게 만들 수 있다.
```ts
let oneMillion = 1_000_000;
```

### bigint
bigint는 자바스크립트와 타입스크립트에 새로 추가된 타입으로 이를 이용하면 라운딩 관련 에러 걱정 없이 큰 정수를 처리할 수 있다.

number 타입은 최대 2^53-1 까지 표현 가능하지만 bigint는 이보다 큰 수도 표현이 가능하다. 모든 숫자 관련 연산도 가능하다.

```js
let a = 1234n; // bigint
const b = 5678n; // 5678n
let c = 88.5n; // TS1353 에러 : bigint 리터럴은 반드시 정수여야 함
let d: bigint = 100; // TS2322 에러 : 100 타입은 bigint 타입에 할당할 수 없음(->100 뒤에 n이 없음)
```

